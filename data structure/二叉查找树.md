<div id="post_detail">

<div id="topics">

<div class="post">

# [二叉查找树](https://www.cnblogs.com/songdechiu/p/6821168.html)

<div class="postBody">

<div id="cnblogs_post_body" class="blogpost-body">

# 一、定义

一棵二叉查找树是一棵二叉树，每个节点都含有一个Comparable的键（以及对应的值）。

每个节点的键都大于左子树中任意节点的键而小于右子树中任意节点的键。

每个节点都有两个链接，左链接、右链接，分别指向自己的左子节点和右子节点，链接也可以指向null。

尽管链接指向的是节点，可以将每个链接看做指向了另一棵二叉树。这个思路能帮助理解二叉查找树的递归方法。

# 二、基本实现

## 1、数据表示

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">class</span> <span style="color: #000000;">Node {</span> <span style="color: #0000ff;">private</span> <span style="color: #000000;">Key key;</span> <span style="color: #0000ff;">private</span> <span style="color: #000000;">Value val;</span> <span style="color: #0000ff;">private</span> <span style="color: #000000;">Node left, right;</span> <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> <span style="color: #000000;">size;</span> <span style="color: #0000ff;">public</span> Node(Key key, Value val, <span style="color: #0000ff;">int</span> <span style="color: #000000;">n) {</span> <span style="color: #0000ff;">this</span>.key = <span style="color: #000000;">key;</span> <span style="color: #0000ff;">this</span>.val = <span style="color: #000000;">val;</span> <span style="color: #0000ff;">this</span>.size = <span style="color: #000000;">n;
            left</span> = right = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }

    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

## 2、测试所有方法的用例

在实现方法后，需要一个用例来测试方法是否正常工作。

以下是用例的代码：

<div class="cnblogs_code" onclick="cnblogs_code_show('8d7a4e5c-451b-4d5e-ad86-145792ae0e7c')">![](https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif)![](https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif)

<div id="cnblogs_code_open_8d7a4e5c-451b-4d5e-ad86-145792ae0e7c" class="cnblogs_code_hide">

<pre><span style="color: #0000ff;">package</span> <span style="color: #000000;">com.qiusongde;</span> <span style="color: #0000ff;">import</span> <span style="color: #000000;">edu.princeton.cs.algs4.StdOut;</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> <span style="color: #000000;">BSTTest {</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">main(String[] args) {

        String test</span> = "S E A R C H E X A M P L E"<span style="color: #000000;">; 
        String[] keys</span> = test.split("\\s+"<span style="color: #000000;">);</span> <span style="color: #0000ff;">int</span> n = <span style="color: #000000;">keys.length;</span> <span style="color: #008000;">//</span><span style="color: #008000;">test put</span>
        StdOut.println("Testing put(Key,Value)"<span style="color: #000000;">);
        BST</span><String, Integer> st = <span style="color: #0000ff;">new</span> BST<String, Integer><span style="color: #000000;">();
        StdOut.println(st);</span> <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i < n; i++<span style="color: #000000;">) {
            st.put(keys[i], i); 
            StdOut.println(</span>"put(" + keys[i] + ", " + i +")"<span style="color: #000000;">);
            StdOut.println(st);
        }</span> <span style="color: #008000;">//</span><span style="color: #008000;">test search hit</span>
        StdOut.println("Testing keys() and get(Key)"<span style="color: #000000;">);
        StdOut.println(</span>"--------------------------------"<span style="color: #000000;">);</span> <span style="color: #0000ff;">for</span> <span style="color: #000000;">(String s : st.keys()) 
            StdOut.println(s</span> + " " + <span style="color: #000000;">st.get(s));</span> <span style="color: #008000;">//</span><span style="color: #008000;">test search miss</span>
        StdOut.println("I" + " " + st.get("I"<span style="color: #000000;">));
        StdOut.println();</span> <span style="color: #008000;">//</span><span style="color: #008000;">test delete</span>
        StdOut.println("Testing delete(Key)"<span style="color: #000000;">);
        StdOut.println(st);

        StdOut.println(</span>"delete E"<span style="color: #000000;">);
        st.delete(</span>"E");<span style="color: #008000;">//</span><span style="color: #008000;">not root, has two subtree</span>
 <span style="color: #000000;">StdOut.println(st);

        StdOut.println(</span>"delete A"<span style="color: #000000;">);
        st.delete(</span>"A");<span style="color: #008000;">//</span><span style="color: #008000;">not root, has right subtree</span>
 <span style="color: #000000;">StdOut.println(st);

        StdOut.println(</span>"delete P"<span style="color: #000000;">);
        st.delete(</span>"P");<span style="color: #008000;">//</span><span style="color: #008000;">not root, has no subtree</span>
 <span style="color: #000000;">StdOut.println(st);

        StdOut.println(</span>"delete L"<span style="color: #000000;">);
        st.delete(</span>"L");<span style="color: #008000;">//</span><span style="color: #008000;">not root, has left subtree</span>
 <span style="color: #000000;">StdOut.println(st);

        StdOut.println(</span>"delete S"<span style="color: #000000;">);
        st.delete(</span>"S");<span style="color: #008000;">//</span><span style="color: #008000;">root, has two subtree</span>
 <span style="color: #000000;">StdOut.println(st);

        StdOut.println(</span>"delete X"<span style="color: #000000;">);
        st.delete(</span>"X"<span style="color: #000000;">);
        StdOut.println(st);</span><span style="color: #008000;">//</span><span style="color: #008000;">root, has subtree</span>

        <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i < n; i++<span style="color: #000000;">) {
            StdOut.println(</span>"delete " + <span style="color: #000000;">keys[i]);
            st.delete(keys[i]); 
            StdOut.println(st);
        }</span> <span style="color: #008000;">//</span><span style="color: #008000;">insert back</span>
        StdOut.println("insert back"<span style="color: #000000;">);</span> <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i < n; i++<span style="color: #000000;">) {
            st.put(keys[i], i); 
        }
        StdOut.println(st);

        StdOut.println(</span>"size = " + <span style="color: #000000;">st.size());
        StdOut.println(</span>"min  = " + <span style="color: #000000;">st.min());
        StdOut.println(</span>"max  = " + <span style="color: #000000;">st.max());
        StdOut.println();</span> <span style="color: #008000;">//</span> <span style="color: #008000;">print keys in order using select</span>
        StdOut.println("Testing select"<span style="color: #000000;">);
        StdOut.println(</span>"--------------------------------"<span style="color: #000000;">);</span> <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i <= st.size(); i++<span style="color: #000000;">)
            StdOut.println(i</span> + " " + <span style="color: #000000;">st.select(i)); 
        StdOut.println();</span> <span style="color: #008000;">//</span> <span style="color: #008000;">test rank, floor, ceiling</span>
        StdOut.println("key rank floor ceil"<span style="color: #000000;">);
        StdOut.println(</span>"-------------------"<span style="color: #000000;">);</span> <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> i = 'A' - 1; i <= 'Z'; i++<span style="color: #000000;">) {
            String s</span> = i + ""<span style="color: #000000;">;
            StdOut.printf(</span>"%2s %4d %4s %4s\n"<span style="color: #000000;">, s, st.rank(s), st.floor(s), st.ceiling(s));
        }
        StdOut.println();</span> <span style="color: #008000;">//</span> <span style="color: #008000;">test range search and range count</span>
        String[] from = { "A", "Z", "X", "0", "B", "C" <span style="color: #000000;">};
        String[] to</span> = { "Z", "A", "X", "Z", "G", "L" <span style="color: #000000;">};
        StdOut.println(</span>"range search"<span style="color: #000000;">);
        StdOut.println(</span>"-------------------"<span style="color: #000000;">);</span> <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i < from.length; i++<span style="color: #000000;">) {
            StdOut.printf(</span>"%s-%s (%2d) : "<span style="color: #000000;">, from[i], to[i], st.size(from[i], to[i]));</span> <span style="color: #0000ff;">for</span> <span style="color: #000000;">(String s : st.keys(from[i], to[i]))
                StdOut.print(s</span> + " "<span style="color: #000000;">);
            StdOut.println();
        }
        StdOut.println();</span> <span style="color: #008000;">//</span> <span style="color: #008000;">delete the smallest keys</span>
 <span style="color: #000000;">StdOut.println(st);
        StdOut.println(</span>"Test deleteMin"<span style="color: #000000;">);</span> <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i < 3; i++<span style="color: #000000;">) {
            st.deleteMin();
            StdOut.println(st);
        }</span> <span style="color: #008000;">//</span> <span style="color: #008000;">delete all the remaining keys, using deleteMax</span>
        StdOut.println("Test deleteMax"<span style="color: #000000;">);</span> <span style="color: #0000ff;">while</span> (!<span style="color: #000000;">st.isEmpty()) {
            st.deleteMax();
            StdOut.println(st);
        }</span> <span style="color: #008000;">//</span> <span style="color: #008000;">under empty, test again</span>
            StdOut.println("under empty, test again"<span style="color: #000000;">);
            StdOut.println(</span>"size = " + <span style="color: #000000;">st.size());
            StdOut.println(</span>"min  = " + <span style="color: #000000;">st.min());
            StdOut.println(</span>"max  = " + <span style="color: #000000;">st.max());
            StdOut.println();</span> <span style="color: #008000;">//</span> <span style="color: #008000;">print keys in order using keys()</span>
            StdOut.println("Testing keys()"<span style="color: #000000;">);
            StdOut.println(</span>"--------------------------------"<span style="color: #000000;">);</span> <span style="color: #0000ff;">for</span> <span style="color: #000000;">(String s : st.keys()) 
                StdOut.println(s</span> + " " + <span style="color: #000000;">st.get(s)); 
            StdOut.println();</span> <span style="color: #008000;">//</span> <span style="color: #008000;">print keys in order using select</span>
            StdOut.println("Testing select"<span style="color: #000000;">);
            StdOut.println(</span>"--------------------------------"<span style="color: #000000;">);</span> <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i <= st.size(); i++<span style="color: #000000;">)
                StdOut.println(i</span> + " " + <span style="color: #000000;">st.select(i)); 
            StdOut.println();</span> <span style="color: #008000;">//</span> <span style="color: #008000;">test rank, floor, ceiling</span>
            StdOut.println("key rank floor ceil"<span style="color: #000000;">);
            StdOut.println(</span>"-------------------"<span style="color: #000000;">);</span> <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">char</span> i = 'A'; i <= 'Z'; i++<span style="color: #000000;">) {
                String s</span> = i + ""<span style="color: #000000;">;
                StdOut.printf(</span>"%2s %4d %4s %4s\n"<span style="color: #000000;">, s, st.rank(s), st.floor(s), st.ceiling(s));
            }
            StdOut.println();</span> <span style="color: #008000;">//</span> <span style="color: #008000;">test range search and range count</span>
            StdOut.println("range search"<span style="color: #000000;">);
            StdOut.println(</span>"-------------------"<span style="color: #000000;">);</span> <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i < from.length; i++<span style="color: #000000;">) {
                StdOut.printf(</span>"%s-%s (%2d) : "<span style="color: #000000;">, from[i], to[i], st.size(from[i], to[i]));</span> <span style="color: #0000ff;">for</span> <span style="color: #000000;">(String s : st.keys(from[i], to[i]))
                    StdOut.print(s</span> + " "<span style="color: #000000;">);
                StdOut.println();
            }
            StdOut.println();</span> <span style="color: #008000;">//</span> <span style="color: #008000;">delete the smallest keys</span>
 <span style="color: #000000;">StdOut.println(st);
            StdOut.println(</span>"Test deleteMin"<span style="color: #000000;">);</span> <span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i < 3; i++<span style="color: #000000;">) {
                st.deleteMin();
                StdOut.println(st);
            }</span> <span style="color: #008000;">//</span> <span style="color: #008000;">delete all the remaining keys, using deleteMax</span>
            StdOut.println("Test deleteMax"<span style="color: #000000;">);</span> <span style="color: #0000ff;">while</span> (!<span style="color: #000000;">st.isEmpty()) {
                st.deleteMax();
                StdOut.println(st);
            }

            StdOut.println();
            StdOut.println(</span>"get(S) under empty"<span style="color: #000000;">);
            StdOut.println(st.get(</span>"S"<span style="color: #000000;">));

            StdOut.println();
            StdOut.println(</span>"delete(S) under empty"<span style="color: #000000;">);
            StdOut.println(st);
            st.delete(</span>"S"<span style="color: #000000;">);
            StdOut.println(st);

    }

}</span></pre>

</div>

<span class="cnblogs_code_collapse">BSTTest</span></div>

需要实现toString来配合测试用例：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #0000ff;">private</span> <span style="color: #000000;">String BSTString(Node x) {</span> <span style="color: #0000ff;">if</span>(x == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> ""<span style="color: #000000;">;

        String s</span> = ""<span style="color: #000000;">;

        s</span> += <span style="color: #000000;">BSTString(x.left);
        s</span> += x.key + " " + x.val + " " + x.size + "(s)\n"<span style="color: #000000;">;
        s</span> += <span style="color: #000000;">BSTString(x.right);</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">s;
    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

## 3、查找实现（search）

思路：

A、如果二叉查找树为空，查找失败（search miss），返回null；

B、如果根节点的键等于要查找的键，返回根节点的值（search hit）。

C、否则，继续在**相应的子树**中查找。如果要查找的键小于根节点的键，在左子树中查找；如果要查找的键大于根节点的键，在右子树中查找。

D、重复ABC步骤，直至search miss或者search hit。

递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #008000;">　　/**</span> <span style="color: #008000;">* Returns the value associated with the given key.
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">key the key
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the value associated with the given key if the key is in the symbol table
     *             and {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null} if the key is not in the symbol table
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException if {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key} is {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #000000;">Value get(Key key) {</span> <span style="color: #0000ff;">if</span>(key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("key is null"<span style="color: #000000;">);</span> <span style="color: #0000ff;">return</span> get(root, key);<span style="color: #008000;">//</span><span style="color: #008000;">work when BST is empty</span>
 <span style="color: #000000;">}</span> <span style="color: #0000ff;">private</span> <span style="color: #000000;">Value get(Node x, Key key) {</span> <span style="color: #0000ff;">if</span>(x == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span>;<span style="color: #008000;">//</span><span style="color: #008000;">serach miss</span>

        <span style="color: #0000ff;">int</span> cmp = <span style="color: #000000;">key.compareTo(x.key);</span> <span style="color: #0000ff;">if</span>(cmp < 0<span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">get(x.left, key);</span> <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(cmp > 0<span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">get(x.right, key);</span> <span style="color: #0000ff;">else</span>
            <span style="color: #0000ff;">return</span> x.val;<span style="color: #008000;">//</span><span style="color: #008000;">serach hit</span>
 <span style="color: #000000;">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

非递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Returns the value associated with the given key.
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">key the key
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the value associated with the given key if the key is in the symbol table
     *             and {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null} if the key is not in the symbol table
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException if {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key} is {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #000000;">Value get(Key key) {</span> <span style="color: #0000ff;">if</span>(key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("key is null"<span style="color: #000000;">);

        Node cur</span> = <span style="color: #000000;">root;</span> <span style="color: #0000ff;">while</span>(cur != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {</span> <span style="color: #0000ff;">int</span> cmp = <span style="color: #000000;">key.compareTo(cur.key);</span> <span style="color: #0000ff;">if</span>(cmp < 0<span style="color: #000000;">)
                cur</span> = <span style="color: #000000;">cur.left;</span> <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(cmp > 0<span style="color: #000000;">)
                cur</span> = <span style="color: #000000;">cur.right;</span> <span style="color: #0000ff;">else</span>
                <span style="color: #0000ff;">return</span> cur.val;<span style="color: #008000;">//</span><span style="color: #008000;">search hit</span>
 <span style="color: #000000;">}</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span>;<span style="color: #008000;">//</span><span style="color: #008000;">search miss</span>
 <span style="color: #000000;">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

## 4、插入实现

思路：

A、如果二叉查找树是空的，生成一个新节点，并返回该节点，相当于插入新节点后的二叉树根节点。

B、如果根节点键和要插入的键相等，更新根节点的值。

C、如果要插入的键小于根节点的键，在左子树插入，并将根节点的左链接指向插入后的左子树。

D、如果要插入的键小于根节点的键，在右子树插入，并将根节点的右链接指向插入后的右子树。

E、更新根节点的size，并返回根节点，作为插入新节点后的二叉树根节点。

F、重复ABCD，直至插入或者更新成功。

递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #008000;">　　/**</span> <span style="color: #008000;">* Inserts the specified key-value pair into the symbol table, overwriting the old 
     * value with the new value if the symbol table already contains the specified key.
     * Deletes the specified key (and its associated value) from this symbol table
     * if the specified value is {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}.
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">key the key
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">val the value
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException if {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key} is {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">put(Key key, Value val) {</span> <span style="color: #0000ff;">if</span>(key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("key is null"<span style="color: #000000;">);</span> <span style="color: #0000ff;">if</span>(val == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            delete(key);</span> <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }

        root</span> = <span style="color: #000000;">put(root, key, val);
    }</span> <span style="color: #0000ff;">private</span> <span style="color: #000000;">Node put(Node x, Key key, Value val) {</span> <span style="color: #0000ff;">if</span>(x == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">new</span> Node(key, val, 1<span style="color: #000000;">);</span> <span style="color: #0000ff;">int</span> cmp = <span style="color: #000000;">key.compareTo(x.key);</span> <span style="color: #0000ff;">if</span>(cmp < 0<span style="color: #000000;">)
            x.left</span> = <span style="color: #000000;">put(x.left, key, val);</span> <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(cmp > 0<span style="color: #000000;">) 
            x.right</span> = <span style="color: #000000;">put(x.right, key, val);</span> <span style="color: #0000ff;">else</span> <span style="color: #000000;">x.val</span> = <span style="color: #000000;">val;

        x.size</span> = size(x.left) + size(x.right) + 1<span style="color: #000000;">;</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x;

    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

 递归实现的，要在**插入之后更新节点的size**。

非递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre><span style="color: #008000;">/**</span> <span style="color: #008000;">* Inserts the specified key-value pair into the symbol table, overwriting the old 
     * value with the new value if the symbol table already contains the specified key.
     * Deletes the specified key (and its associated value) from this symbol table
     * if the specified value is {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}.
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">key the key
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">val the value
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException if {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key} is {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">put(Key key, Value val) {</span> <span style="color: #0000ff;">if</span>(key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("key is null"<span style="color: #000000;">);</span> <span style="color: #0000ff;">if</span>(val == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            delete(key);</span> <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }</span> <span style="color: #ff0000;">if(root == null) {
            root = new Node(key, val);
            return;
        }</span> <span style="color: #0000ff;">boolean</span> <span style="color: #ff0000;">alreadyin</span> = contains(key);<span style="color: #008000;">//</span><span style="color: #008000;">see if it needs to update the counts</span>
        Node <span style="color: #ff0000;">parent</span> = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        Node cur</span> = <span style="color: #000000;">root;</span> <span style="color: #0000ff;">while</span>(cur != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            parent</span> = <span style="color: #000000;">cur;
 <span style="color: #ff0000;">cur.size</span></span><span style="color: #ff0000;">= alreadyin ? cur.size : cur.size + 1;//change size of cur
</span>            
            <span style="color: #0000ff;">int</span> cmp = <span style="color: #000000;">key.compareTo(cur.key);</span> <span style="color: #0000ff;">if</span>(cmp < 0<span style="color: #000000;">)
                cur</span> = <span style="color: #000000;">cur.left;</span> <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(cmp > 0<span style="color: #000000;">)
                cur</span> = <span style="color: #000000;">cur.right;</span> <span style="color: #0000ff;">else</span> <span style="color: #000000;">{
                cur.val</span> = <span style="color: #000000;">val;</span> <span style="color: #0000ff;">return</span><span style="color: #000000;">;
            }
        }</span> <span style="color: #0000ff;">if</span>(key.compareTo(parent.key) < 0<span style="color: #000000;">)
            parent.left</span> = <span style="color: #0000ff;">new</span> <span style="color: #000000;">Node(key, val);</span> <span style="color: #0000ff;">else</span> <span style="color: #000000;">parent.right</span> = <span style="color: #0000ff;">new</span> <span style="color: #000000;">Node(key, val);

    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

非递归实现的比较麻烦，需要处理一些特殊情况：

A、**需要记录父节点**，用于更新父节点的链接。

B、还要处理一个**特殊情况**，就是**根节点**就是要插入的位置。

C、还要多调用一次get，用于判断要插入的键值对是否已经在二叉搜索树中。如果在就不用更新size，如果不在就需要更新size。

D、非递归实现更新size跟递归实现的顺序相反，要**边搜索边更改size**。

<span style="color: #ff0000;">注：后边只要改变二叉搜索树结构的，非递归实现都需要考虑这些特殊情况，如insert或delete等。</span>

## 5、min实现和max实现

以min为例：

思路：

A、如果根节点的左链接是null，返回根节点。

B、否则继续在左子树中查找。

C、重复AB，直至找到一个根节点的左链接是null。

递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Returns the smallest key in the symbol table.
     * 
     * If the symbol table is empty, return {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}.
     * 
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the smallest key in the symbol table</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #000000;">Key min() {</span> <span style="color: #0000ff;">if</span><span style="color: #000000;">(isEmpty())</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">min(root).key;
    }</span> <span style="color: #0000ff;">private</span> <span style="color: #000000;">Node min(Node x) {</span> <span style="color: #0000ff;">if</span>(x.left == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x;</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">min(x.left);
    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

非递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Returns the smallest key in the symbol table.
     * 
     * If the symbole table is empty, return {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}.
     * 
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the smallest key in the symbol table</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #000000;">Key min() {</span> <span style="color: #0000ff;">if</span><span style="color: #000000;">(isEmpty())</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">min(root).key;

    }</span> <span style="color: #0000ff;">private</span> Node min(Node x) {<span style="color: #008000;">//</span><span style="color: #008000;">x must not be null</span>

        <span style="color: #0000ff;">if</span>(x == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("Node x must not be null"<span style="color: #000000;">);

        Node cur</span> = <span style="color: #000000;">x;</span> <span style="color: #0000ff;">while</span>(cur.left != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            cur</span> = <span style="color: #000000;">cur.left;
        }</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">cur;

    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

这里private的min函数，在后边**delete**需要调用到。

max的思路和min思路基本差不多，只是左右相反即可。

递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Return the largest key in the symbol table.
     * 
     * If the symbol table is empty, return {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}
     * 
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the largest key in the symbol table</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #000000;">Key max() {</span> <span style="color: #0000ff;">if</span><span style="color: #000000;">(isEmpty())</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">max(root).key;
    }</span> <span style="color: #0000ff;">private</span> <span style="color: #000000;">Node max(Node x) {</span> <span style="color: #0000ff;">if</span>(x.right == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x;</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">max(x.right);
    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

非递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Return the largest key in the symbol table.
     * 
     * If the symbol table is empty, return {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}
     * 
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the largest key in the symbol table</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #000000;">Key max() {</span> <span style="color: #0000ff;">if</span><span style="color: #000000;">(isEmpty())</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        Node cur</span> = <span style="color: #000000;">root;</span> <span style="color: #0000ff;">while</span>(cur.right != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            cur</span> = <span style="color: #000000;">cur.right;
        }</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">cur.key;

    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

## 6、floor和ceiling实现

floor是求the largest key in the BST less than or equal to _key_

思路：

A、如果根节点是null，则直接返回null。

B、如果根节点键值大于_key_，则继续floor(key)在左子树中，所以继续在左子树中查找。

C、如果根节点键值刚好等于_key_，则根节点的键值即为floor(key)，直接返回该键。

D、如果根节点键值小于_key_，那么根节点的key有可能就是floor(key)，**只要**右子树中不存在节点的key小于等于输入的_key。_

E、重复ABCD

递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Return the largest key in the symbol table less than or equal to {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key}.
     * 
     * If the symbol table is empty, return {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">key the key
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the largest key in the symbol table less than or equal to {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key}
     * 
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException if {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key} is {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #000000;">Key floor(Key key) {</span> <span style="color: #0000ff;">if</span>(key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("key is null"<span style="color: #000000;">);

        Node x</span> = floor(root, key);<span style="color: #008000;">//</span><span style="color: #008000;">work when BST is empty</span>

        <span style="color: #0000ff;">if</span>(x == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x.key;

    }</span> <span style="color: #0000ff;">private</span> <span style="color: #000000;">Node floor(Node x, Key key) {</span> <span style="color: #0000ff;">if</span>(x == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;</span> <span style="color: #0000ff;">int</span> cmp = <span style="color: #000000;">key.compareTo(x.key);</span> <span style="color: #0000ff;">if</span>(cmp == 0<span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x;</span> <span style="color: #0000ff;">if</span>(cmp < 0<span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> floor(x.left, key);<span style="color: #008000;">//</span><span style="color: #008000;">in left subtree</span>
 <span style="color: #000000;">Node t</span> = floor(x.right, key);<span style="color: #008000;">//</span><span style="color: #008000;">see if right subtree has a key is the floor(key)</span>
        <span style="color: #0000ff;">if</span>(t != <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> t;<span style="color: #008000;">//</span><span style="color: #008000;">yes, return t</span>
        <span style="color: #0000ff;">else</span>
            <span style="color: #0000ff;">return</span> x;<span style="color: #008000;">//</span><span style="color: #008000;">no, return x</span>
 <span style="color: #000000;">}</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

非递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Return the largest key in the symbol table less than or equal to {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key}.
     * 
     * If the symbol table is empty, return {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">key the key
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the largest key in the symbol table less than or equal to {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key}
     * 
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException if {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key} is {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #000000;">Key floor(Key key) {</span> <span style="color: #0000ff;">if</span>(key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("key is null"<span style="color: #000000;">);

        Node cur</span> = <span style="color: #000000;">root;
        Key result</span> = <span style="color: #0000ff;">null</span><span style="color: #000000;">;</span> <span style="color: #0000ff;">while</span>(cur != <span style="color: #0000ff;">null</span>) {<span style="color: #008000;">//</span><span style="color: #008000;">it works when BST is empty</span>
            <span style="color: #0000ff;">int</span> cmp = <span style="color: #000000;">key.compareTo(cur.key);</span> <span style="color: #0000ff;">if</span>(cmp < 0<span style="color: #000000;">) {
                cur</span> = <span style="color: #000000;">cur.left;
            }</span> <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(cmp > 0<span style="color: #000000;">) {
                result</span> = cur.key;<span style="color: #008000;">//</span><span style="color: #008000;">may be updated</span>
                cur = cur.right;<span style="color: #008000;">//</span><span style="color: #008000;">see if the right subtree has a key smaller than or equal to key</span>
 <span style="color: #000000;">}</span> <span style="color: #0000ff;">else</span> <span style="color: #000000;">{</span> <span style="color: #0000ff;">return</span> cur.key;<span style="color: #008000;">//</span><span style="color: #008000;">final result</span>
 <span style="color: #000000;">}
        }</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">result;

    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

这里用result来缓存，用于解决思路中D的情况。

ceiling和floor思路差不多，只不过左右对调过来。

递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Return the smallest key in the symbol table larger than or equal to {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key}.
     * 
     * If the symbol table is empty, return {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}.
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">key the key 
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the smallest key in the symbol table larger than or equal to {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key}
     * 
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException if {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key} is {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #000000;">Key ceiling(Key key) {</span> <span style="color: #0000ff;">if</span>(key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("key is null"<span style="color: #000000;">);

        Node x</span> = ceiling(root, key);<span style="color: #008000;">//</span><span style="color: #008000;">work when BST is empty</span>

        <span style="color: #0000ff;">if</span>(x == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x.key;

    }</span> <span style="color: #0000ff;">private</span> <span style="color: #000000;">Node ceiling(Node x, Key key) {</span> <span style="color: #0000ff;">if</span>(x == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;</span> <span style="color: #0000ff;">int</span> cmp = <span style="color: #000000;">key.compareTo(x.key);</span> <span style="color: #0000ff;">if</span>(cmp == 0<span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x;</span> <span style="color: #0000ff;">if</span>(cmp > 0<span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">ceiling(x.right, key);

        Node t</span> = <span style="color: #000000;">ceiling(x.left, key);</span> <span style="color: #0000ff;">if</span>(t != <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">t;</span> <span style="color: #0000ff;">else</span>
            <span style="color: #0000ff;">return</span> <span style="color: #000000;">x;

    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

非递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Return the smallest key in the symbol table larger than or equal to {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key}.
     * 
     * If the symbol table is empty, return {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}.
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">key the key 
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the smallest key in the symbol table larger than or equal to {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key}
     * 
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException if {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key} is {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #000000;">Key ceiling(Key key) {</span> <span style="color: #0000ff;">if</span>(key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("key is null"<span style="color: #000000;">);

        Node cur</span> = <span style="color: #000000;">root;
        Key result</span> = <span style="color: #0000ff;">null</span><span style="color: #000000;">;</span> <span style="color: #0000ff;">while</span>(cur != <span style="color: #0000ff;">null</span>) {<span style="color: #008000;">//</span><span style="color: #008000;">it works when BST is empty</span>
            <span style="color: #0000ff;">int</span> cmp = <span style="color: #000000;">key.compareTo(cur.key);</span> <span style="color: #0000ff;">if</span>(cmp < 0<span style="color: #000000;">) {
                result</span> = cur.key;<span style="color: #008000;">//</span><span style="color: #008000;">may be updated</span>
                cur = <span style="color: #000000;">cur.left;
            }</span> <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(cmp > 0<span style="color: #000000;">) {
                cur</span> = <span style="color: #000000;">cur.right;
            }</span> <span style="color: #0000ff;">else</span> <span style="color: #000000;">{</span> <span style="color: #0000ff;">return</span> cur.key;<span style="color: #008000;">//</span><span style="color: #008000;">final result</span>
 <span style="color: #000000;">}

        }</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">result;

    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

## 7、select实现

**size是专门为select和rank等函数准备的。**

思路：

A、如果根节点为null，直接返回null。

B、如果左子树的节点个数为t，select(k)，如果t=k，那么直接返回根节点的值。

C、如果t>k，根节点的排序太大，需要在左子树中继续select(k)。

D、如果t<k，根节点的排序太小，需要在右子树中继续select(k-t-1)。

E、重复ABCD

递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Return the kth smallest key in the symbol table.
     * 
     * When k is 0, return the smallest key. When k is <em>N</em> &minus; 1, return the largest key.
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">k the order statistic
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the kth smallest key in the symbol table
     * 
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException unless {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">k} is between 0 and
     *        <em>N</em> &minus; 1</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> Key select(<span style="color: #0000ff;">int</span> <span style="color: #000000;">k) {</span> <span style="color: #0000ff;">if</span>(k < 0 || k >= <span style="color: #000000;">size())</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        Node x</span> = select(root, k);<span style="color: #008000;">//</span><span style="color: #008000;">work when BST is empty</span>

        <span style="color: #0000ff;">if</span>(x == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x.key;

    }</span> <span style="color: #0000ff;">private</span> Node select(Node x, <span style="color: #0000ff;">int</span> <span style="color: #000000;">k) {</span> <span style="color: #0000ff;">if</span>(x == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;</span> <span style="color: #0000ff;">int</span> t = <span style="color: #000000;">size(x.left);</span> <span style="color: #0000ff;">if</span>(t > <span style="color: #000000;">k)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">select(x.left, k);</span> <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(t < <span style="color: #000000;">k)</span> <span style="color: #0000ff;">return</span> select(x.right, k - t - 1<span style="color: #000000;">);</span> <span style="color: #0000ff;">else</span>
            <span style="color: #0000ff;">return</span> <span style="color: #000000;">x;

    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

非递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Return the kth smallest key in the symbol table.
     * 
     * When k is 0, return the smallest key. When k is <em>N</em> &minus; 1, return the largest key.
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">k the order statistic
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the kth smallest key in the symbol table
     * 
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException unless {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">k} is between 0 and
     *        <em>N</em> &minus; 1</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> Key select(<span style="color: #0000ff;">int</span> <span style="color: #000000;">k) {</span> <span style="color: #0000ff;">if</span>(k < 0 || k >= size())<span style="color: #008000;">//</span><span style="color: #008000;">include the empty situation</span>
            <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        Node cur</span> = <span style="color: #000000;">root;</span> <span style="color: #0000ff;">while</span>(cur != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {</span> <span style="color: #0000ff;">int</span> less = <span style="color: #000000;">size(cur.left);</span> <span style="color: #0000ff;">if</span>(less < <span style="color: #000000;">k) {
                cur</span> = <span style="color: #000000;">cur.right;
                k</span> = k - less - 1<span style="color: #000000;">;
            }</span> <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(less > <span style="color: #000000;">k) {
                cur</span> = <span style="color: #000000;">cur.left;
            }</span> <span style="color: #0000ff;">else</span> <span style="color: #000000;">{</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">cur.key;
            }
        }</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;

    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

## 8、rank实现

思路：

A、如果根节点为null，返回0。

B、如果根节点的键刚好等于_key_，返回左子树的节点个数（刚好只有左子树的所有键小于_key_）。

C、如果根节点的键大于_key_，则在左子树中rank(_key_)（只有左子树才有小于_key_的键）。

D、如果根节点的键小于_key_，则除了左子树所有键都小于_key_外，右子树也可能有小于_key_的键，则返回左子树的节点个数+rank(key)在右子树的值+1。

E、重复ABCD。

递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* 
     * Return the number of keys in the symbol table strictly less than {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key}.
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">key the key 
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the number of keys in the symbol table strictly less than {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key}
     * 
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException if key is {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> <span style="color: #000000;">rank(Key key) {</span> <span style="color: #0000ff;">if</span>(key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("key is null"<span style="color: #000000;">);</span> <span style="color: #0000ff;">return</span> rank(root, key);<span style="color: #008000;">//</span><span style="color: #008000;">work when BST is empty</span>
 <span style="color: #000000;">}</span> <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> <span style="color: #000000;">rank(Node x, Key key) {</span> <span style="color: #0000ff;">if</span>(x == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;</span> <span style="color: #0000ff;">int</span> cmp = <span style="color: #000000;">key.compareTo(x.key);</span> <span style="color: #0000ff;">if</span>(cmp < 0<span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">rank(x.left, key);</span> <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(cmp > 0<span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> size(x.left) + 1 + <span style="color: #000000;">rank(x.right, key);</span> <span style="color: #0000ff;">else</span>
            <span style="color: #0000ff;">return</span> <span style="color: #000000;">size(x.left);

    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

非递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* 
     * Return the number of keys in the symbol table strictly less than {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key}.
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">key the key 
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the number of keys in the symbol table strictly less than {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key}
     * 
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException if key is {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> <span style="color: #000000;">rank(Key key) {</span> <span style="color: #0000ff;">if</span>(key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("key is null"<span style="color: #000000;">);    

        Node cur</span> = <span style="color: #000000;">root;</span> <span style="color: #0000ff;">int</span> result = 0<span style="color: #000000;">;</span> <span style="color: #0000ff;">while</span>(cur != <span style="color: #0000ff;">null</span>) {<span style="color: #008000;">//</span><span style="color: #008000;">work when BST is empty</span>
            <span style="color: #0000ff;">int</span> cmp = <span style="color: #000000;">key.compareTo(cur.key);</span> <span style="color: #0000ff;">if</span>(cmp < 0<span style="color: #000000;">) {
                cur</span> = <span style="color: #000000;">cur.left;
            }</span> <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(cmp > 0<span style="color: #000000;">) {
                result</span> += size(cur.left) + 1<span style="color: #000000;">;
                cur</span> = <span style="color: #000000;">cur.right;
            }</span> <span style="color: #0000ff;">else</span> <span style="color: #000000;">{</span> <span style="color: #0000ff;">return</span> result + <span style="color: #000000;">size(cur.left);
            }
        }</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">result;

    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

9、删除最小值和最大值

**思路：**

**一直往左走，直到到达左链接为null的节点x（最小值），然后将指向该节点x的链接替换为x.right。**

递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Removes the smallest key and its associated value from the symbol table
     * 
     * If the symbol table is empty, do nothing.
     *</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">deleteMin() {</span> <span style="color: #0000ff;">if</span><span style="color: #000000;">(isEmpty())</span> <span style="color: #0000ff;">return</span>;<span style="color: #008000;">//</span><span style="color: #008000;">do nothing</span>
        root = <span style="color: #000000;">deleteMin(root);
    }</span> <span style="color: #0000ff;">private</span> <span style="color: #000000;">Node deleteMin(Node x) {</span> <span style="color: #0000ff;">if</span>(x.left == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x.right;

        x.left</span> = <span style="color: #000000;">deleteMin(x.left);
        x.size</span> = size(x.left) + size(x.right) + 1<span style="color: #000000;">;</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x;
    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

非递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Removes the smallest key and its associated value from the symbol table
     * 
     * If the symbol table is empty, do nothing.
     *</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">deleteMin() {</span> <span style="color: #0000ff;">if</span><span style="color: #000000;">(isEmpty())</span> <span style="color: #0000ff;">return</span>;<span style="color: #008000;">//</span><span style="color: #008000;">do nothing</span>
 <span style="color: #000000;">root</span> = <span style="color: #000000;">deleteMin(root);

    }</span> <span style="color: #0000ff;">private</span> Node deleteMin(Node x) {<span style="color: #008000;">//</span><span style="color: #008000;">x must not be null</span>

 <span style="color: #ff0000;">if(x.left == null) {
            return</span><span style="color: #000000;"><span style="color: #ff0000;">x.right;
        }</span>

        Node cur</span> = <span style="color: #000000;">x;
       <span style="color: #ff0000;">Node parent</span></span><span style="color: #ff0000;">= null;</span> <span style="color: #0000ff;">while</span>(cur.left != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
           <span style="color: #ff0000;"> cur.size</span></span><span style="color: #ff0000;">--</span><span style="color: #000000;"><span style="color: #ff0000;">;</span>
            parent</span> = <span style="color: #000000;">cur;
            cur</span> = <span style="color: #000000;">cur.left;
        }
        parent.left</span> = <span style="color: #000000;">cur.right;</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x;

    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

非递归：

A、**需要记录父节点**，用于更新父节点的链接。

B、还要处理一个**特殊情况**，就是**根节点**就是要删除的节点。

C、非递归实现更新size跟递归实现的顺序相反，要**边搜索边更改size**。

删除最大值思路差不多，左右相反而已。

递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Removes the largest key and associated value from the symbol table.
     * 
     * If the symbol table is empty, do nothing.</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">deleteMax() {</span> <span style="color: #0000ff;">if</span><span style="color: #000000;">(isEmpty())</span> <span style="color: #0000ff;">return</span>; <span style="color: #008000;">//</span><span style="color: #008000;">do nothing</span>
        root = <span style="color: #000000;">deleteMax(root);
    }</span> <span style="color: #0000ff;">private</span> <span style="color: #000000;">Node deleteMax(Node x) {</span> <span style="color: #0000ff;">if</span>(x.right == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x.left;

        x.right</span> = <span style="color: #000000;">deleteMax(x.right);
        x.size</span> = size(x.left) + size(x.right) + 1<span style="color: #000000;">;</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x;
    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

非递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Removes the largest key and associated value from the symbol table.
     * 
     * If the symbol table is empty, do nothing.</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">deleteMax() {</span> <span style="color: #0000ff;">if</span><span style="color: #000000;">(isEmpty())</span> <span style="color: #0000ff;">return</span>;<span style="color: #008000;">//</span><span style="color: #008000;">do nothing</span>

 <span style="color: #ff0000;">if(root.right == null) {
            root = root.left;
            return</span><span style="color: #000000;"><span style="color: #ff0000;">;
        }</span>

        Node cur</span> = <span style="color: #000000;">root;
        Node <span style="color: #ff0000;">parent</span></span> = <span style="color: #0000ff;">null</span><span style="color: #000000;">;</span> <span style="color: #0000ff;">while</span>(cur.right != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            <span style="color: #ff0000;">cur.size</span></span><span style="color: #ff0000;">--</span><span style="color: #000000;"><span style="color: #ff0000;">;</span>
            parent</span> = <span style="color: #000000;">cur;
            cur</span> = <span style="color: #000000;">cur.right;
        }
        parent.right</span> = <span style="color: #000000;">cur.left;

    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

非递归：

A、**需要记录父节点**，用于更新父节点的链接。

B、还要处理一个**特殊情况**，就是**根节点**就是要删除的节点。

C、非递归实现更新size跟递归实现的顺序相反，要**边搜索边更改size**。

## 10、删除节点

如果要删除的节点x只有子节点或者没有子节点，那么可以效仿删除最小值和最大值的做法。

如果有两个子节点呢？应该在右子树中找继承者来替换x，然后再返回x。

步骤：

A、用t保存即将删除的节点x。

B、将x指向右子树的最小键节点，也就是继承者。

C、x.right = deleteMin(t.right)。

D、x.left = t.left。

递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Removes the specified key and its associated value from this symbol table
     * If the key is not in this symbol table or this symbol table is empty, do nothing
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">key the key
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException if {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key} if {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">delete(Key key) {</span> <span style="color: #0000ff;">if</span>(key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("key is null"<span style="color: #000000;">);</span> <span style="color: #0000ff;">if</span><span style="color: #000000;">(isEmpty())</span> <span style="color: #0000ff;">return</span>; <span style="color: #008000;">//</span><span style="color: #008000;">do nothing</span>
 <span style="color: #000000;">root</span> = <span style="color: #000000;">delete(root, key);

    }</span> <span style="color: #0000ff;">private</span> <span style="color: #000000;">Node delete(Node x, Key key) {</span> <span style="color: #0000ff;">if</span>(x == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;</span> <span style="color: #0000ff;">int</span> cmp = <span style="color: #000000;">key.compareTo(x.key);</span> <span style="color: #0000ff;">if</span>(cmp < 0<span style="color: #000000;">)
            x.left</span> = delete(x.left, key);<span style="color: #008000;">//</span><span style="color: #008000;">left subtree</span>
        <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(cmp > 0<span style="color: #000000;">)
            x.right</span> = delete(x.right, key);<span style="color: #008000;">//</span><span style="color: #008000;">right subtree</span>
        <span style="color: #0000ff;">else</span> <span style="color: #000000;">{</span> <span style="color: #0000ff;">if</span>(x.right == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x.left;</span> <span style="color: #0000ff;">if</span>(x.left == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x.right;

            Node temp</span> = x;<span style="color: #008000;">//</span><span style="color: #008000;">save the node to be deleted</span>
            x = min(temp.right);<span style="color: #008000;">//</span><span style="color: #008000;">set x to point to its successor min(temp.right)</span>
            x.right = deleteMin(temp.right);<span style="color: #008000;">//</span><span style="color: #008000;">set the right link of the successor to deleteMin(temp.right)</span>
            x.left = temp.left;<span style="color: #008000;">//</span><span style="color: #008000;">set the left link of the successor to t.left</span>
 <span style="color: #000000;">}

        x.size</span> = size(x.left) + size(x.right) + 1<span style="color: #000000;">;</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">x;
    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

非递归实现：

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Removes the specified key and its associated value from this symbol table
     * If the key is not in this symbol table or this symbol talbe is empty, do nothing
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">key the key
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException if {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key} if {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> <span style="color: #000000;">delete(Key key) {</span> <span style="color: #0000ff;">if</span>(key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("key is null"<span style="color: #000000;">);</span> <span style="color: #0000ff;">if</span>(!contains(key) || <span style="color: #000000;">isEmpty()) {</span> <span style="color: #0000ff;">return</span>;<span style="color: #008000;">//</span><span style="color: #008000;">do nothing</span>
 <span style="color: #000000;">}</span> <span style="color: #0000ff;">if</span>(key.compareTo(root.key) == 0<span style="color: #000000;">) {
            deleteRoot();</span> <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }

        Node cur</span> = <span style="color: #000000;">root;
        Node parent</span> = <span style="color: #0000ff;">null</span><span style="color: #000000;">;</span> <span style="color: #0000ff;">while</span>(cur != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {</span> <span style="color: #0000ff;">int</span> cmp = <span style="color: #000000;">key.compareTo(cur.key);</span> <span style="color: #0000ff;">if</span>(cmp < 0<span style="color: #000000;">) {
                cur.size</span>--<span style="color: #000000;">;
                parent</span> = cur;<span style="color: #008000;">//</span><span style="color: #008000;">record parent</span>
                cur = <span style="color: #000000;">cur.left;
            }</span> <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span>(cmp > 0<span style="color: #000000;">){
                cur.size</span>--<span style="color: #000000;">;
                parent</span> = cur;<span style="color: #008000;">//</span><span style="color: #008000;">record parent</span>
                cur = <span style="color: #000000;">cur.right;
            }</span> <span style="color: #0000ff;">else</span> <span style="color: #000000;">{</span> <span style="color: #0000ff;">int</span> parentcmp = <span style="color: #000000;">key.compareTo(parent.key);</span> <span style="color: #0000ff;">if</span>(cur.left == <span style="color: #0000ff;">null</span>) {<span style="color: #008000;">//</span><span style="color: #008000;">special case</span>
                    <span style="color: #0000ff;">if</span>(parentcmp < 0<span style="color: #000000;">) {
                        parent.left</span> = <span style="color: #000000;">cur.right;
                    }</span> <span style="color: #0000ff;">else</span> <span style="color: #000000;">{
                        parent.right</span> = <span style="color: #000000;">cur.right;
                    }</span> <span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }</span> <span style="color: #0000ff;">if</span>(cur.right == <span style="color: #0000ff;">null</span>) {<span style="color: #008000;">//</span><span style="color: #008000;">special case</span>
                    <span style="color: #0000ff;">if</span>(parentcmp < 0<span style="color: #000000;">) {
                        parent.left</span> = <span style="color: #000000;">cur.left;
                    }</span> <span style="color: #0000ff;">else</span> <span style="color: #000000;">{
                        parent.right</span> = <span style="color: #000000;">cur.left;
                    }</span> <span style="color: #0000ff;">return</span><span style="color: #000000;">;
                }

                Node temp</span> = <span style="color: #000000;">cur;
                cur</span> = min(temp.right);<span style="color: #008000;">//</span><span style="color: #008000;">temp.right will not be null</span>
                cur.right = <span style="color: #000000;">deleteMin(temp.right);
                cur.left</span> = <span style="color: #000000;">temp.left;
                cur.size</span> = size(cur.left) + size(cur.right) + 1<span style="color: #000000;">;</span> <span style="color: #0000ff;">if</span>(parentcmp < 0<span style="color: #000000;">) {
                    parent.left</span> = <span style="color: #000000;">cur;
                }</span> <span style="color: #0000ff;">else</span> <span style="color: #000000;">{
                    parent.right</span> = <span style="color: #000000;">cur;
                }</span> <span style="color: #0000ff;">return</span><span style="color: #000000;">;

            }
        }

    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

这个非递归的实现太麻烦了，有很多特殊情况需要处理。

A、**需要记录父节点**，用于更新父节点的链接。

B、还要处理一个**特殊情况**，就是**根节点**就是要删除的节点。

C、还要多调用一次get，用于判断要删除的节点是否在二叉搜索树中。

D、非递归实现更新size跟递归实现的顺序相反，要**边搜索边更改size**。

## 11、其他操作

<div class="cnblogs_code">

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

<pre>    <span style="color: #008000;">/**</span> <span style="color: #008000;">* Returns all keys in the symbol table as an {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">Iterable}.
     * To iterate over all of the keys in the symbol table named {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">st},
     * use the foreach notation: {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">for (Key key : st.keys())}.
     * 
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">all keys in the symbol table</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> Iterable<Key> <span style="color: #000000;">keys() {</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">keys(min(), max());
    }</span> <span style="color: #008000;">/**</span> <span style="color: #008000;">* Returns all keys in the symbol table in the given range,
     * as an {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">Iterable}.
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">lo minimum endpoint
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">hi maximum endpoint
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">all keys in the symbol table between {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">lo} 
     *         (inclusive) and {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">hi} (inclusive)
     *         
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException if either {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">lo} or {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">hi}
     *         is {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> Iterable<Key> <span style="color: #000000;">keys(Key lo, Key hi) {
        LinkedList</span><Key> queue = <span style="color: #0000ff;">new</span> LinkedList<><span style="color: #000000;">();
        keys(root, queue, lo, hi);</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">queue;
    }</span> <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> keys(Node x, LinkedList<Key> <span style="color: #000000;">queue, Key lo, Key hi) {</span> <span style="color: #0000ff;">if</span>(x == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span><span style="color: #000000;">;</span> <span style="color: #0000ff;">int</span> cmplo = <span style="color: #000000;">lo.compareTo(x.key);</span> <span style="color: #0000ff;">int</span> cmphi = <span style="color: #000000;">hi.compareTo(x.key);</span> <span style="color: #0000ff;">if</span>(cmplo < 0<span style="color: #000000;">)
            keys(x.left, queue, lo, hi);</span> <span style="color: #0000ff;">if</span>(cmplo <= 0 && cmphi >= 0<span style="color: #000000;">)
            queue.add(x.key);</span> <span style="color: #0000ff;">if</span>(cmphi > 0<span style="color: #000000;">)
            keys(x.right, queue, lo, hi);

    }</span> <span style="color: #008000;">/**</span> <span style="color: #008000;">* Returns the number of key-value pairs in this symbol table.
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the number of key-value pairs in this symbol table</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> <span style="color: #000000;">size() {</span> <span style="color: #0000ff;">return</span> <span style="color: #000000;">size(root);
    }</span> <span style="color: #008000;">/**</span> <span style="color: #008000;">* Returns the number of keys in the symbol table in the given range.
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">lo    minimum endpoint
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">hi    maximum endpoint
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">the number of keys in the symbol table between {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">lo} 
     *         (inclusive) and {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">hi} (inclusive)
     *         
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException if either {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">lo} or {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">hi}
     *         is {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> <span style="color: #000000;">size(Key lo, Key hi) {</span> <span style="color: #0000ff;">if</span>(lo == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("lo is null"<span style="color: #000000;">);</span> <span style="color: #0000ff;">if</span>(hi == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("hi is null"<span style="color: #000000;">);</span> <span style="color: #0000ff;">if</span>(hi.compareTo(lo) < 0<span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;</span> <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span><span style="color: #000000;">(contains(hi))</span> <span style="color: #0000ff;">return</span> rank(hi) - rank(lo) + 1<span style="color: #000000;">;</span> <span style="color: #0000ff;">else</span> 
            <span style="color: #0000ff;">return</span> rank(hi) - <span style="color: #000000;">rank(lo);
    }</span> <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> <span style="color: #000000;">size(Node x)    {</span> <span style="color: #0000ff;">if</span>(x == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">return</span> 0<span style="color: #000000;">;</span> <span style="color: #0000ff;">else</span>
            <span style="color: #0000ff;">return</span> <span style="color: #000000;">x.size;
    }</span> <span style="color: #008000;">/**</span> <span style="color: #008000;">* Returns true if this symbol table is empty.
     * 
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">{</span><span style="color: #808080;">@code</span> <span style="color: #008000;">true} if this symbol table is empty; {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">false} otherwise</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span> <span style="color: #000000;">isEmpty() {</span> <span style="color: #0000ff;">return</span> size() == 0<span style="color: #000000;">;
    }</span> <span style="color: #008000;">/**</span> <span style="color: #008000;">* Does this symbol table contain the given key?
     * 
     *</span> <span style="color: #808080;">@param</span> <span style="color: #008000;">key the key
     *</span> <span style="color: #808080;">@return</span> <span style="color: #008000;">{</span><span style="color: #808080;">@code</span> <span style="color: #008000;">true} if this symbol table contains {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key} and
     *             {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">false} otherwise
     *         
     *</span> <span style="color: #808080;">@throws</span> <span style="color: #008000;">IllegalArgumentException if {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">key} is {</span><span style="color: #808080;">@code</span> <span style="color: #008000;">null}</span> <span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span> <span style="color: #000000;">contains(Key key) {</span> <span style="color: #0000ff;">if</span>(key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)</span> <span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span> IllegalArgumentException("key is null"<span style="color: #000000;">);</span> <span style="color: #0000ff;">return</span> get(key) != <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }</span></pre>

<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy">[![复制代码](//common.cnblogs.com/images/copycode.gif)](javascript:void(0); "复制代码")</span></div>

</div>

# 三、性能分析

假设键的顺序是随机的，也就是插入的顺序是随机的。

这个的分析其实和快排是差不多的。

**结论1：**<span style="color: #000000;">在N个随机键构造的二叉查找树中，**查找命中**平均需要的比较次数为~2lnN ~1.39log<sub>2</sub>N。</span>

<span style="color: #000000;">证明：</span>

<span style="color: #000000;">定义**内部路径长度**为所有节点的**深度**的和。</span>

<span style="color: #000000;">令I<sub>N</sub>为N个随机排序的不同键**构造**而成的二叉查找树的内部路径长度，其中I<sub>0</sub>=I<sub>1</sub>=0。</span>

<span style="color: #000000;">则I<sub>N</sub> = （**N-1**） + （I<sub>0</sub>+I<sub>N-1</sub>）/N + （I<sub>1</sub>+C<sub>N-2</sub>）/N + …… + （I<sub>N-1</sub>+I<sub>0</sub>）/N。</span>

<span style="color: #000000;">根节点使两个子树所有节点的深度都加1，也就是**N-1**。</span>

<span style="color: #000000;">这个的分析跟快排的分析差不多，I<sub>N</sub>~2NlnN。</span>

<span style="color: #000000;">平均比较次数为：1+I<sub>N</sub>/N~2lnN。</span>

<span style="color: #000000;">**结论2：**在N个随机键构造的二叉查找树中，**插入和查找失败**平均需要的比较次数为~2lnN ~1.39log<sub>2</sub>N</span>

<span style="color: #000000;">证明：</span>

<span style="color: #000000;">定义**外部路径长度**为根节点到所有null节点的所有路径的节点总和。</span>

令E<sub>N</sub>为N个随机排序的不同键**构造**而成的二叉查找树的外部路径长度，其中E<sub>0</sub>=0，E<sub>1</sub>=2。

则E<sub>N</sub> = （N+1） + （E<sub>0</sub>+E<sub>N-1</sub>）/N + （E<sub>1</sub>+E<sub>N-2</sub>）/N + …… + （E<sub>N-1</sub>+E<sub>0</sub>）/N。

其中**N+1**为经过根节点的总路径的总和为**N+1**。这里还需要证明有N个节点的二叉树，其null链接为N+1。所以总路径数为N+1。

N个节点，总共有2N个链接，其中除了根节点外，每个节点都有一个链接指向该节点，故总共有N-1个链接指向节点，剩下2N-(N-1)=N+1个链接指向null。

E<sub>N</sub>的分析和I<sub>N</sub>差不多。

**<span style="color: #000000;">结论3：</span>**<span style="color: #000000;">E</span><span style="color: #000000;"><sub>N</sub>=I<sub>N</sub>+2N</span>

<span style="color: #000000;">用归纳法，即可证明。略。</span>

**<span style="color: #000000;">结论4：</span><span style="color: #000000;">插入和查找失败平均比查找成功多一次比较。</span>**

<span style="color: #000000;">证明：</span>

<span style="color: #000000;">插入和查找失败平均比较次数为E<sub>N</sub>/N，查找成功平均比较次数为I<sub>N</sub>/N+1。</span>

<span style="color: #000000;">EN/N-(I<sub>N</sub>/N+1)=(EN-IN)/N - 1= 2N/N - 1 = 1。</span>

**结论5：**在一棵二叉查找树中，所有操作在最坏情况下所需的时间都和树的**高度**成正比。

树的高度将会比平均内部路径长度要大。对于足够大的N，高度趋近于**2.99logN**。

但是构造树的键**不是随机**的话，最坏情况将会变得不可接受。比如用例按照顺序或者逆序插入符号表。

这种情况还是有可能出现的，因为用例控制着插入和查找等操作的顺序。

**平衡二叉查找树（红黑树）**可以解决这个问题。

</div>

<div id="blog_post_info_block">

<div id="blog_post_info">

<div id="green_channel">[好文要顶](javascript:void(0);) [关注我](javascript:void(0);) [收藏该文](javascript:void(0);) [![](//common.cnblogs.com/images/icon_weibo_24.png)](javascript:void(0); "分享至新浪微博") [![](//common.cnblogs.com/images/wechat.png)](javascript:void(0); "分享至微信")</div>

<div id="author_profile">

<div id="author_profile_info" class="author_profile_info">[![](//pic.cnblogs.com/face/833392/20151106230457.png)](https://home.cnblogs.com/u/songdechiu/)

<div id="author_profile_detail" class="author_profile_info">[我是老邱](https://home.cnblogs.com/u/songdechiu/)  
[关注 - 2](https://home.cnblogs.com/u/songdechiu/followees)  
[粉丝 - 24](https://home.cnblogs.com/u/songdechiu/followers)</div>

</div>

<div id="author_profile_follow">[+加关注](javascript:void(0);)</div>

</div>

<div id="div_digg">

<div class="diggit" onclick="votePost(6821168,'Digg')"><span class="diggnum" id="digg_count">0</span></div>

<div class="buryit" onclick="votePost(6821168,'Bury')"><span class="burynum" id="bury_count">0</span></div>

</div>

<script type="text/javascript">currentDiggType = 0;</script></div>

<div id="post_next_prev">[«](https://www.cnblogs.com/songdechiu/p/6819003.html) 上一篇：[Symbol Table（符号表）](https://www.cnblogs.com/songdechiu/p/6819003.html "发布于2017-05-06 23:20")  
[»](https://www.cnblogs.com/songdechiu/p/6935394.html) 下一篇：[四则运算](https://www.cnblogs.com/songdechiu/p/6935394.html "发布于2017-06-03 10:26")  
</div>

</div>

</div>

<div class="postDesc">posted @ <span id="post-date">2017-05-07 17:35</span> [我是老邱](https://www.cnblogs.com/songdechiu/) 阅读(<span id="post_view_count">5544</span>) 评论(<span id="post_comment_count">0</span>) [编辑](https://i.cnblogs.com/EditPosts.aspx?postid=6821168) [收藏](#)</div>

</div>

<script type="text/javascript">var allowComments=true,cb_blogId=252744,cb_entryId=6821168,cb_blogApp=currentBlogApp,cb_blogUserGuid='6a6eaaa9-9684-e511-9fc1-ac853d9f53cc',cb_entryCreatedDate='2017/5/7 17:35:00';loadViewCount(cb_entryId);var cb_postType=1;var isMarkdown=false;</script></div>

</div>
